# Архитектура

Данные обрабатываются по следующей схеме:
<p align="center">
<img src="images/dataflow.jpg" />
</p> 

Пользователь вводит в CLI команду, которая должна быть исполнена. Строка преобразовывается в Escaped String, которая разграничивает обычные символы от экранированных. 

<p align="center">
<img src="images/3.png" />
</p>

Следующим этапом является парсинг этой строки: приоритетным является парсер Pipeline, который разбивает строку по пайпам('|') и далее каждая отдельная часть, заключенная между пайпами парсится отдельно. После этого приоритет у Assignment Parser, который пытается разобрать в строке присваивание, собственно, если он его находит, тогда записывает в Environment переменную, которая хранится для следующей ее замены. И на самый конец Parser встроенной команды. 

<p align="center">
<img src="images/1.png" />
</p> 

Внутри себя парсеры для удобства работы разбивают EscapedString на токены с помощью класса Tokenizer. Это позволяет легко абстрагироваться и отделить имя команды от аргументов. Также, есть ReplaceToken, которые будут заменятся в дальнейшем при исполнении команды на значения, которые пользователь сохранил до этого.

<p align="center">
<img src="images/2.png" />
</p>

Каждый из парсеров возвращает разобранный Operator, который умеет исполнять то, что ввел пользователь. В зависимости от ввода исполняется подходящий Оператор: Pipeline, Assignment, Builtin. 
Передав оператору Environment он исполнит команду: вызовет у environment команду с нужным именем, с нужными аргументами, а также заменит с помощью того же объекта переменные указанные со знаком '$'. 
Environment уже внутри себя либо находит подходящую утилиту, которую до этого в нее регистрировали(свои утилиты) либо вызывается внешняя утилита в ином случае.
Возвращается в итоге объект типа ExecutionResult, содержащий вывод команды, а также флаг нужно ли завершится(команда Exit может завершать сессию с пользователем)

